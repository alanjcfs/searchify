{"name":"Searchify","body":"Requirements\r\n------------\r\n* Rails 3.1\r\n* jQuery\r\n* jQuery UI (for the autocomplete widget)\r\n\r\nInstallation\r\n------------\r\nFirst, install the gem\r\n\r\n    gem install searchify\r\n\r\nMount the engine to the desired route in `config/routes.rb`\r\n\r\n    mount Searchify::Engine => \"/searchify\", :as => \"searchify\"\r\n\r\nAdd both jquery-ui and searchify to your `app/assets/javascripts/application.js` file\r\n\r\n    //= require jquery-ui\r\n    //= require searchify/searchify\r\n\r\nFinally, call the `searchify()` method on all `.searchify` fields.\r\n\r\n    $('.searchify').searchify();\r\n\r\nUsage\r\n-----\r\n### Autocomplete search\r\n\r\nSearchify is intended to be used on a per model basis. You type, you choose, you are redirected to the chosen resource show page.\r\nCalling it on an index page, it infers the model to be searched with the controller name, or the `resource_class` helper, if it exists.\r\nFor example, consider the following line of code on your `/posts` page:\r\n\r\n    <%= searchify %>\r\n\r\nThis will triggers an AJAX call to `/searchify/search/posts.json` page and jQuery will handle the response with its autocomplete widget.\r\n\r\nIf you want to specify the collection, i.e. searching for `users` on the `posts` page, just write this:\r\n\r\n    <%= searchify :users %>\r\n\r\nWhen a selection is made, you are redirected to the chosen resource show page. If you want to land on any other member action, the `action` option is for you.\r\n\r\n    <%= searchify :action => :edit %>\r\n\r\nIf your redirect is more complex, you can always redefine the `select_url` option. The `(id)` keyword will be replaced by the id of the selected resource.\r\n\r\n    <%= searchify :select_url => \"/more/complex/path/(id)/with/custom/action\" %>\r\n\r\n### In place autocomplete\r\n\r\nSearchify can also be used in a form. For example, let's say that a post belongs to a user of your choice:\r\n\r\n    <%= form_for(@post) do |f| %>\r\n        <div class=\"field\">\r\n            <%= f.label :user %><br />\r\n            <%= f.searchify :user %>\r\n        </div>\r\n    <% end %>\r\n\r\nSearchify will include a `user_id` field in your form, which will be automatically populated with your search. Searchify uses the `label_method` option to display the object.\r\n\r\n### Scopes\r\n\r\nSearchify is by default scopes aware. Let's say you are here:\r\n\r\n`/posts?created_by=3`\r\n\r\nAssuming your `Post` model responds to the `created_by` method, it will be included in the search.\r\n\r\nYou may also force your own scopes into a searchify field by adding the `scopes` options, as follow:\r\n\r\n    <%= searchify :scopes => {:created_by => 3} %>\r\n\r\n### Configuration\r\n\r\nYou can always override the defaults with an initializer. Options are as follow:\r\n\r\n    Searchify::Config.configure do |config|\r\n\r\n        # Extract those keys from the params hash\r\n        config.scope_exclusion  = %w( controller action format collection term page )\r\n\r\n        # Default column names on which you want to do your search\r\n        config.column_names     = %w( name title abbreviation )\r\n\r\n        # If true, searchify will apply url scopes to your search\r\n        config.scope_awareness  = true\r\n\r\n        # Limit the number of results in one search\r\n        config.limit            = 30\r\n\r\n        # Database search key. Default is 'ILIKE' for Postgres, 'LIKE' for others.\r\n        config.search_key       = nil\r\n\r\n        # Method to be called on each resource\r\n        config.label_method     = :name\r\n\r\n        # Default action on which you want to land after a selection. Could be :show, :edit or any custom member action\r\n        config.default_action   = :show\r\n    end\r\n\r\n### Search stategies\r\n\r\nBy default, Searchify does a case insensitive search on `name`, `title` and `abbreviation` fields of your models, if they exist.\r\nTo override the default search strategy, just define a class method named `search_strategy` in your model. It should accepts two arguments and returns an array of hashes.\r\n\r\n    class User < ActiveRecord::Base\r\n        def self.search_strategy(term, scopes)\r\n            columns = %w( username, first_name, last_name )\r\n\r\n            scoped = where( columns.map{ |c| \"(#{c} ILIKE :term)\" }.join(' OR '), :term => \"%#{term}%\")\r\n\r\n            scopes.each do |key, value|\r\n              scoped = scoped.send(key, value) if respond_to?(key)\r\n            end\r\n\r\n            scoped.map do |user|\r\n              {:label => user.username, :id => user.id}\r\n            end\r\n        end\r\n    end\r\n\r\nYou may also want to use a per-search search strategy, without affecting the default one. The `search_strategy` option is for you.\r\n\r\n    <%= searchify :users, :search_strategy => :my_custom_method %>\r\n\r\nSearchify will then try to call your `User.my_custom_method`. It must accepts two arguments, and still return an array of hashes.","tagline":"Searchify provides a quick way to search your collections. Type, choose, enjoy!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}